// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: habit_stats.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const decrementTotalCompletions = `-- name: DecrementTotalCompletions :one
UPDATE habit_stats
SET total_completions = GREATEST(0, total_completions - 1),
    updated_at = CURRENT_TIMESTAMP
WHERE user_id = $1 AND habit_id = $2
RETURNING id, user_id, habit_id, max_streak, total_completions, created_at, updated_at
`

type DecrementTotalCompletionsParams struct {
	UserID  int32 `json:"user_id"`
	HabitID int32 `json:"habit_id"`
}

func (q *Queries) DecrementTotalCompletions(ctx context.Context, arg DecrementTotalCompletionsParams) (HabitStats, error) {
	row := q.db.QueryRow(ctx, decrementTotalCompletions, arg.UserID, arg.HabitID)
	var i HabitStats
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.HabitID,
		&i.MaxStreak,
		&i.TotalCompletions,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllUserHabitStats = `-- name: GetAllUserHabitStats :many
SELECT id, user_id, habit_id, max_streak, total_completions, created_at, updated_at FROM habit_stats
WHERE user_id = $1
ORDER BY habit_id
`

func (q *Queries) GetAllUserHabitStats(ctx context.Context, userID int32) ([]HabitStats, error) {
	rows, err := q.db.Query(ctx, getAllUserHabitStats, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HabitStats{}
	for rows.Next() {
		var i HabitStats
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.HabitID,
			&i.MaxStreak,
			&i.TotalCompletions,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHabitStats = `-- name: GetHabitStats :one
SELECT id, user_id, habit_id, max_streak, total_completions, created_at, updated_at FROM habit_stats
WHERE user_id = $1 AND habit_id = $2
`

type GetHabitStatsParams struct {
	UserID  int32 `json:"user_id"`
	HabitID int32 `json:"habit_id"`
}

func (q *Queries) GetHabitStats(ctx context.Context, arg GetHabitStatsParams) (HabitStats, error) {
	row := q.db.QueryRow(ctx, getHabitStats, arg.UserID, arg.HabitID)
	var i HabitStats
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.HabitID,
		&i.MaxStreak,
		&i.TotalCompletions,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const incrementTotalCompletions = `-- name: IncrementTotalCompletions :one
UPDATE habit_stats
SET total_completions = total_completions + 1,
    updated_at = CURRENT_TIMESTAMP
WHERE user_id = $1 AND habit_id = $2
RETURNING id, user_id, habit_id, max_streak, total_completions, created_at, updated_at
`

type IncrementTotalCompletionsParams struct {
	UserID  int32 `json:"user_id"`
	HabitID int32 `json:"habit_id"`
}

func (q *Queries) IncrementTotalCompletions(ctx context.Context, arg IncrementTotalCompletionsParams) (HabitStats, error) {
	row := q.db.QueryRow(ctx, incrementTotalCompletions, arg.UserID, arg.HabitID)
	var i HabitStats
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.HabitID,
		&i.MaxStreak,
		&i.TotalCompletions,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMaxStreak = `-- name: UpdateMaxStreak :one
UPDATE habit_stats
SET max_streak = GREATEST(max_streak, $3),
    updated_at = CURRENT_TIMESTAMP
WHERE user_id = $1 AND habit_id = $2
RETURNING id, user_id, habit_id, max_streak, total_completions, created_at, updated_at
`

type UpdateMaxStreakParams struct {
	UserID    int32       `json:"user_id"`
	HabitID   int32       `json:"habit_id"`
	MaxStreak pgtype.Int4 `json:"max_streak"`
}

func (q *Queries) UpdateMaxStreak(ctx context.Context, arg UpdateMaxStreakParams) (HabitStats, error) {
	row := q.db.QueryRow(ctx, updateMaxStreak, arg.UserID, arg.HabitID, arg.MaxStreak)
	var i HabitStats
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.HabitID,
		&i.MaxStreak,
		&i.TotalCompletions,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertHabitStats = `-- name: UpsertHabitStats :one
INSERT INTO habit_stats (user_id, habit_id, max_streak, total_completions)
VALUES ($1, $2, $3, $4)
ON CONFLICT (user_id, habit_id)
DO UPDATE SET
    max_streak = GREATEST(habit_stats.max_streak, EXCLUDED.max_streak),
    total_completions = EXCLUDED.total_completions,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, user_id, habit_id, max_streak, total_completions, created_at, updated_at
`

type UpsertHabitStatsParams struct {
	UserID           int32       `json:"user_id"`
	HabitID          int32       `json:"habit_id"`
	MaxStreak        pgtype.Int4 `json:"max_streak"`
	TotalCompletions pgtype.Int4 `json:"total_completions"`
}

func (q *Queries) UpsertHabitStats(ctx context.Context, arg UpsertHabitStatsParams) (HabitStats, error) {
	row := q.db.QueryRow(ctx, upsertHabitStats,
		arg.UserID,
		arg.HabitID,
		arg.MaxStreak,
		arg.TotalCompletions,
	)
	var i HabitStats
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.HabitID,
		&i.MaxStreak,
		&i.TotalCompletions,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
