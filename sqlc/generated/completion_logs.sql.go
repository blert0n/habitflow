// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: completion_logs.sql

package db

import (
	"context"
)

const getAllHabitCompletions = `-- name: GetAllHabitCompletions :many
SELECT date, TRUE as completed, time as timeAtCompletion
FROM habit_completions_log
WHERE habit_id = $1
  AND user_id = $2
  ORDER BY date DESC
`

type GetAllHabitCompletionsParams struct {
	HabitID int32 `json:"habit_id"`
	UserID  int32 `json:"user_id"`
}

type GetAllHabitCompletionsRow struct {
	Date             string `json:"date"`
	Completed        bool   `json:"completed"`
	Timeatcompletion string `json:"timeatcompletion"`
}

func (q *Queries) GetAllHabitCompletions(ctx context.Context, arg GetAllHabitCompletionsParams) ([]GetAllHabitCompletionsRow, error) {
	rows, err := q.db.Query(ctx, getAllHabitCompletions, arg.HabitID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllHabitCompletionsRow{}
	for rows.Next() {
		var i GetAllHabitCompletionsRow
		if err := rows.Scan(&i.Date, &i.Completed, &i.Timeatcompletion); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompletionsInRange = `-- name: GetCompletionsInRange :many
SELECT date, TRUE as completed, time as timeAtCompletion
FROM habit_completions_log
WHERE habit_id = $1
  AND user_id = $2
  AND date BETWEEN $3 AND $4
ORDER By id desc
`

type GetCompletionsInRangeParams struct {
	HabitID int32  `json:"habit_id"`
	UserID  int32  `json:"user_id"`
	Date    string `json:"date"`
	Date_2  string `json:"date_2"`
}

type GetCompletionsInRangeRow struct {
	Date             string `json:"date"`
	Completed        bool   `json:"completed"`
	Timeatcompletion string `json:"timeatcompletion"`
}

func (q *Queries) GetCompletionsInRange(ctx context.Context, arg GetCompletionsInRangeParams) ([]GetCompletionsInRangeRow, error) {
	rows, err := q.db.Query(ctx, getCompletionsInRange,
		arg.HabitID,
		arg.UserID,
		arg.Date,
		arg.Date_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCompletionsInRangeRow{}
	for rows.Next() {
		var i GetCompletionsInRangeRow
		if err := rows.Scan(&i.Date, &i.Completed, &i.Timeatcompletion); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isCompleted = `-- name: IsCompleted :one
SELECT EXISTS (
    SELECT 1
    FROM habit_completions_log
    WHERE habit_id = $1
      AND user_id = $2
      AND date = $3
) AS is_completed
`

type IsCompletedParams struct {
	HabitID int32  `json:"habit_id"`
	UserID  int32  `json:"user_id"`
	Date    string `json:"date"`
}

func (q *Queries) IsCompleted(ctx context.Context, arg IsCompletedParams) (bool, error) {
	row := q.db.QueryRow(ctx, isCompleted, arg.HabitID, arg.UserID, arg.Date)
	var is_completed bool
	err := row.Scan(&is_completed)
	return is_completed, err
}

const markAsCompletedDemo = `-- name: MarkAsCompletedDemo :exec
INSERT INTO habit_completions_log (
    habit_id,
    user_id,
    date,
    time
)
SELECT $1, $2, $3, $4
WHERE NOT EXISTS (
    SELECT 1
    FROM habit_completions_log
    WHERE habit_id = $1
      AND user_id = $2
      AND date = $3
)
`

type MarkAsCompletedDemoParams struct {
	HabitID int32  `json:"habit_id"`
	UserID  int32  `json:"user_id"`
	Date    string `json:"date"`
	Time    string `json:"time"`
}

func (q *Queries) MarkAsCompletedDemo(ctx context.Context, arg MarkAsCompletedDemoParams) error {
	_, err := q.db.Exec(ctx, markAsCompletedDemo,
		arg.HabitID,
		arg.UserID,
		arg.Date,
		arg.Time,
	)
	return err
}

const markAsIncomplete = `-- name: MarkAsIncomplete :exec
DELETE FROM habit_completions_log
WHERE habit_id = $1
  AND user_id = $2
  AND date = $3
`

type MarkAsIncompleteParams struct {
	HabitID int32  `json:"habit_id"`
	UserID  int32  `json:"user_id"`
	Date    string `json:"date"`
}

func (q *Queries) MarkAsIncomplete(ctx context.Context, arg MarkAsIncompleteParams) error {
	_, err := q.db.Exec(ctx, markAsIncomplete, arg.HabitID, arg.UserID, arg.Date)
	return err
}

const markHabitAsCompleted = `-- name: MarkHabitAsCompleted :one
INSERT INTO habit_completions_log (
    habit_id,
    user_id,
    date,
    time
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, habit_id, user_id, date, time
`

type MarkHabitAsCompletedParams struct {
	HabitID int32  `json:"habit_id"`
	UserID  int32  `json:"user_id"`
	Date    string `json:"date"`
	Time    string `json:"time"`
}

func (q *Queries) MarkHabitAsCompleted(ctx context.Context, arg MarkHabitAsCompletedParams) (HabitCompletionsLog, error) {
	row := q.db.QueryRow(ctx, markHabitAsCompleted,
		arg.HabitID,
		arg.UserID,
		arg.Date,
		arg.Time,
	)
	var i HabitCompletionsLog
	err := row.Scan(
		&i.ID,
		&i.HabitID,
		&i.UserID,
		&i.Date,
		&i.Time,
	)
	return i, err
}
