// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: habits.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createHabit = `-- name: CreateHabit :one
INSERT INTO habits (
    name,
    description,
    categoryId,
    color,
    frequency,
    userId,
    createdAt,
    updatedAt
) VALUES (
    $1, $2, $3, $4, $5, $6, NOW(), NOW()
)
RETURNING id, name, description, createdat, updatedat, categoryid, color, frequency, userid
`

type CreateHabitParams struct {
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	Categoryid  pgtype.Int4 `json:"categoryid"`
	Color       pgtype.Text `json:"color"`
	Frequency   pgtype.Text `json:"frequency"`
	Userid      pgtype.Int4 `json:"userid"`
}

func (q *Queries) CreateHabit(ctx context.Context, arg CreateHabitParams) (Habits, error) {
	row := q.db.QueryRow(ctx, createHabit,
		arg.Name,
		arg.Description,
		arg.Categoryid,
		arg.Color,
		arg.Frequency,
		arg.Userid,
	)
	var i Habits
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Createdat,
		&i.Updatedat,
		&i.Categoryid,
		&i.Color,
		&i.Frequency,
		&i.Userid,
	)
	return i, err
}

const createHabitExcludedDate = `-- name: CreateHabitExcludedDate :exec
INSERT INTO habit_excluded_dates (
    habit_id,
    excluded_date
) VALUES (
    $1, $2
)
`

type CreateHabitExcludedDateParams struct {
	HabitID      int32       `json:"habit_id"`
	ExcludedDate pgtype.Date `json:"excluded_date"`
}

func (q *Queries) CreateHabitExcludedDate(ctx context.Context, arg CreateHabitExcludedDateParams) error {
	_, err := q.db.Exec(ctx, createHabitExcludedDate, arg.HabitID, arg.ExcludedDate)
	return err
}

const deleteHabit = `-- name: DeleteHabit :exec
DELETE FROM habits
WHERE id = $1 AND userId = $2
`

type DeleteHabitParams struct {
	ID     int32       `json:"id"`
	Userid pgtype.Int4 `json:"userid"`
}

func (q *Queries) DeleteHabit(ctx context.Context, arg DeleteHabitParams) error {
	_, err := q.db.Exec(ctx, deleteHabit, arg.ID, arg.Userid)
	return err
}

const deleteHabitExcludedDate = `-- name: DeleteHabitExcludedDate :exec
DELETE FROM habit_excluded_dates
WHERE habit_id = $1
  AND excluded_date = $2
`

type DeleteHabitExcludedDateParams struct {
	HabitID      int32       `json:"habit_id"`
	ExcludedDate pgtype.Date `json:"excluded_date"`
}

func (q *Queries) DeleteHabitExcludedDate(ctx context.Context, arg DeleteHabitExcludedDateParams) error {
	_, err := q.db.Exec(ctx, deleteHabitExcludedDate, arg.HabitID, arg.ExcludedDate)
	return err
}

const getHabitByID = `-- name: GetHabitByID :one
SELECT id, name, description, createdat, updatedat, categoryid, color, frequency, userid FROM habits
WHERE id = $1
`

func (q *Queries) GetHabitByID(ctx context.Context, id int32) (Habits, error) {
	row := q.db.QueryRow(ctx, getHabitByID, id)
	var i Habits
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Createdat,
		&i.Updatedat,
		&i.Categoryid,
		&i.Color,
		&i.Frequency,
		&i.Userid,
	)
	return i, err
}

const listHabitExcludedDates = `-- name: ListHabitExcludedDates :many
SELECT excluded_date FROM habit_excluded_dates
WHERE habit_id = $1
`

func (q *Queries) ListHabitExcludedDates(ctx context.Context, habitID int32) ([]pgtype.Date, error) {
	rows, err := q.db.Query(ctx, listHabitExcludedDates, habitID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []pgtype.Date{}
	for rows.Next() {
		var excluded_date pgtype.Date
		if err := rows.Scan(&excluded_date); err != nil {
			return nil, err
		}
		items = append(items, excluded_date)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHabits = `-- name: ListHabits :many
SELECT h.id,
       h.name,
       h.description,
       h.createdAt,
       h.updatedAt,
       h.categoryId,
       h.color,
       h.frequency,
       h.userId,
       COALESCE(array_agg(he.excluded_date ORDER BY he.excluded_date) FILTER (WHERE he.excluded_date IS NOT NULL), '{}') AS excluded_dates
FROM habits h
LEFT JOIN habit_excluded_dates he ON he.habit_id = h.id
WHERE h.userId = $1
GROUP BY h.id
ORDER BY h.id
`

type ListHabitsRow struct {
	ID            int32            `json:"id"`
	Name          string           `json:"name"`
	Description   pgtype.Text      `json:"description"`
	Createdat     pgtype.Timestamp `json:"createdat"`
	Updatedat     pgtype.Timestamp `json:"updatedat"`
	Categoryid    pgtype.Int4      `json:"categoryid"`
	Color         pgtype.Text      `json:"color"`
	Frequency     pgtype.Text      `json:"frequency"`
	Userid        pgtype.Int4      `json:"userid"`
	ExcludedDates interface{}      `json:"excluded_dates"`
}

func (q *Queries) ListHabits(ctx context.Context, userid pgtype.Int4) ([]ListHabitsRow, error) {
	rows, err := q.db.Query(ctx, listHabits, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListHabitsRow{}
	for rows.Next() {
		var i ListHabitsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Createdat,
			&i.Updatedat,
			&i.Categoryid,
			&i.Color,
			&i.Frequency,
			&i.Userid,
			&i.ExcludedDates,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHabitsByUser = `-- name: ListHabitsByUser :many
SELECT id, name, description, createdat, updatedat, categoryid, color, frequency, userid FROM habits
WHERE userId = $1
ORDER BY id
`

func (q *Queries) ListHabitsByUser(ctx context.Context, userid pgtype.Int4) ([]Habits, error) {
	rows, err := q.db.Query(ctx, listHabitsByUser, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Habits{}
	for rows.Next() {
		var i Habits
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Createdat,
			&i.Updatedat,
			&i.Categoryid,
			&i.Color,
			&i.Frequency,
			&i.Userid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const seedHabit = `-- name: SeedHabit :exec
INSERT INTO habits (id, name, description, categoryId, color, frequency, userId)
SELECT $1, $2, $3, $4, $5, $6, $7
WHERE NOT EXISTS (
    SELECT 1 FROM habits WHERE id = $1
)
`

type SeedHabitParams struct {
	ID          int32       `json:"id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	Categoryid  pgtype.Int4 `json:"categoryid"`
	Color       pgtype.Text `json:"color"`
	Frequency   pgtype.Text `json:"frequency"`
	Userid      pgtype.Int4 `json:"userid"`
}

func (q *Queries) SeedHabit(ctx context.Context, arg SeedHabitParams) error {
	_, err := q.db.Exec(ctx, seedHabit,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Categoryid,
		arg.Color,
		arg.Frequency,
		arg.Userid,
	)
	return err
}

const updateHabit = `-- name: UpdateHabit :one
UPDATE habits
SET name = $2,
    description = $3,
    categoryId = $4,
    color = $5,
    frequency = $6,
    updatedAt = CURRENT_TIMESTAMP
WHERE id = $1 AND userId= $7
RETURNING id, name, description, createdat, updatedat, categoryid, color, frequency, userid
`

type UpdateHabitParams struct {
	ID          int32       `json:"id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	Categoryid  pgtype.Int4 `json:"categoryid"`
	Color       pgtype.Text `json:"color"`
	Frequency   pgtype.Text `json:"frequency"`
	Userid      pgtype.Int4 `json:"userid"`
}

func (q *Queries) UpdateHabit(ctx context.Context, arg UpdateHabitParams) (Habits, error) {
	row := q.db.QueryRow(ctx, updateHabit,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Categoryid,
		arg.Color,
		arg.Frequency,
		arg.Userid,
	)
	var i Habits
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Createdat,
		&i.Updatedat,
		&i.Categoryid,
		&i.Color,
		&i.Frequency,
		&i.Userid,
	)
	return i, err
}
